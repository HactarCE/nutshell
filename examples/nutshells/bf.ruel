@NUTSHELL bf

 0: Vacuum

 1: +  {PLUS}
 2: -  {MINUS}
 3: ]  {R_BRACK}
 4: [  {L_BRACK}
 5: <  {R_ANGLE}
 6: >  {L_ANGLE}
 7: .  {DOT}
 8: ,  {COMMA}

 9: Plain pointer  {POINTER}
10: Pointer +  {POINTER_PLUS}
11: Pointer -  {POINTER_MINUS}
12: Pointer [  {POINTER_R_BRACK}
13: Pointer <  {POINTER_R_ANGLE}
14: Pointer >  {POINTER_L_ANGLE}
15: Pointer .  {POINTER_DOT}
16: Pointer ,  {POINTER_COMMA}
17: Westbound backtracking pointer  {WEST_POINTER}

18: Northbound no-op {NORTH_NOP}

19: Northbound +  {NORTH_PLUS}
20: Northbound -  {NORTH_MINUS}
21: Northbound ]  {NORTH_R_BRACK}
22: Northbound <  {NORTH_R_ANGLE}
23: Northbound >  {NORTH_L_ANGLE}
24: Northbound .  {NORTH_DOT}
25: Northbound ,  {NORTH_COMMA}

26: Westbound +  {WEST_PLUS}
27: Westbound -  {WEST_MINUS}
28: Westbound ]  {WEST_R_BRACK}
29: Westbound <  {WEST_R_ANGLE}
30: Westbound >  {WEST_L_ANGLE}
31: Westbound .  {WEST_DOT}
32: Westbound ,  {WEST_COMMA}

33: Eastbound +  {EAST_PLUS}
34: Eastbound -  {EAST_MINUS}
35: Eastbound ]  {EAST_R_BRACK}
36: Eastbound <  {EAST_R_ANGLE}
37: Eastbound >  {EAST_L_ANGLE}
38: Eastbound .  {EAST_DOT}
39: Eastbound ,  {EAST_COMMA}

40: Southbound +  {SOUTH_PLUS}
41: Southbound -  {SOUTH_MINUS}
42: Southbound ]  {SOUTH_R_BRACK}
43: Southbound <  {SOUTH_R_ANGLE}
44: Southbound >  {SOUTH_L_ANGLE}
45: Southbound .  {SOUTH_DOT}
46: Southbound ,  {SOUTH_COMMA}

47: Eastward-pointing shadow cell  {EAST_SHADOW}
48: Westward-pointing shadow cell  {WEST_SHADOW}

49: Westward shadow +  {WEST_SHADOW_PLUS}
50: Westward shadow -  {WEST_SHADOW_MINUS}
51: Westward shadow ]  {WEST_SHADOW_R_BRACK}
52: Westward shadow <  {WEST_SHADOW_R_ANGLE}
53: Westward shadow >  {WEST_SHADOW_L_ANGLE}
54: Westward shadow .  {WEST_SHADOW_DOT}
55: Westward shadow ,  {WEST_SHADOW_COMMA}

56: Eastward shadow +  {EAST_SHADOW_PLUS}
57: Eastward shadow -  {EAST_SHADOW_MINUS}
58: Eastward shadow ]  {EAST_SHADOW_R_BRACK}
59: Eastward shadow <  {EAST_SHADOW_R_ANGLE}
60: Eastward shadow >  {EAST_SHADOW_L_ANGLE}
61: Eastward shadow .  {EAST_SHADOW_DOT}
62: Eastward shadow ,  {EAST_SHADOW_COMMA}

63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 
77: 
78: 
79: 
80: 


+ Setup:
    Data pointer is placed anywhere, and data is initalized as unary stacks one cell north of it.
    Program tape is placed so its west end is one cell south and at least two cells east of the data pointer.
    A single state-49 shadow cell is placed directly north of this west end, exactly one row below the data pointer.

+ Post-setup initialization (autonomy starts here):
    Program-tape cells touching a state-3 ] or state-2 [ move down one cell. This change cascades inward until bracket pairs are properly telescoped.
    The instruction pointer starts immediately, being placed initially in the cell directly northwest of the prgm-tape west end -- assuming balanced
    brackets, it will never be able to "beat" the bracket-telescoping (because both happen at lightspeed), so there is no point in delaying its start.

+ Program execution:
    The instruction pointer reads the cell below it.
      [ pass
      ] send TST signal to shadow -> data pointer, which detects whether it has anything above it and returns either 37 (false) or 38 (true)
          false: pass
          true: become state 12 and move west until touching a state-2 [
      + send INC signal to shadow -> data pointer
      - send DEC signal to shadow -> data pointer
      > send RGT signal to shadow -> data pointer
      < send LFT signal to shadow -> data pointer
      , pause and instruct the comma to reel in all stacked unary data below it, which is then fed to shadow -> data pointer as INC
      . send OUT signal to data pointer, which just sends a reader/outputter state-34 up that accumulates to its right
    The instruction pointer will at every step send two signals: one northward to tell the shadow cell to move with it, and one southward
    (passing through the program tape) to tell the input tape to move with it.

+ Input
    The input tape will be stacked vertically in unary, with one state-0 cell separating successive input segments.
    The prgm-tape head will at every execution step send a signal cell downward (by turning the prgm cell below it into a state)


@COLORS
C8C8C8: 0


@ICONS
?  00FFFF .. FFF
0: C8C8C8
1: DFFFFF
2: CFFFFF
3: EFFFFF
4: AFFFFF
5: 70FFFF
6: 00FFFF
7: FFFFFF
8: FF00FF
9: 0000FF

#C empty space; 18 47..62
x = 13, y = 13, rule = //10
5.3A$5.3A$2.9A$2.3A3.3A$2.3A3.3A$3A7.3A$3A7.3A$3A7.3A$2.3A3.3A$2.3A3.
3A$2.9A$5.3A$5.3A!

#C Left bracket 4
x = 5, y = 11, rule = //10
5B$5B$2B$2B$2B$2B$2B$2B$2B$5B$5B!

#C Right bracket 3
x = 5, y = 11, rule = //10
5B$5B$3.2B$3.2B$3.2B$3.2B$3.2B$3.2B$3.2B$5B$5B!

#C Plus sign
#C 1 19 26 33 40
x = 11, y = 11, rule = //10
4.3C$4.3C$4.3C$4.3C$11C$11C$11C$4.3C$4.3C$4.3C$4.3C!

#C Minus sign
#C 2 20 27 34 41
x = 11, y = 3, rule = //10
11C$11C$11C!

#C Left angle bracket
#C 6 23 30 37 44
x = 11, y = 11, rule = //10
9.2D$7.4D$5.4D$3.4D$.4D$3D$.4D$3.4D$5.4D$7.4D$9.2D!

#C Right angle bracket
#C 5 22 29 36 43
x = 11, y = 11, rule = //10
2D$4D$2.4D$4.4D$6.4D$8.3D$6.4D$4.4D$2.4D$4D$2D!

#C Comma
#C 8 25 32 39 46
x = 9, y = 11, rule = //10
.7E$9E$9E$9E$9E$9E$.8E$5.4E$5.4E$4.4E$.6E!
    
#C Period
#C 7 24 31 45
x = 9, y = 7, rule = //10
.7E$9E$9E$9E$9E$9E$.7E!

#C "V" shape (pointer)
#C 9..17
x = 9, y = 9, rule = //10
2G5.2G$2G5.2G$.2G3.2G$.2G3.2G$2.2G.2G$2.2G.2G$3.3G$3.3G$4.G!

#C Data pointer; none yet
x = 9, y = 9, rule = //10
4.I$3.3I$3.3I$2.2I.2I$2.2I.2I$.2I3.2I$.2I3.2I$2I5.2I$2I5.2I!


@TABLE
states: ?
neighborhood: Moore
symmetries: none

anyPrgm = (PLUS..COMMA)
prgm = anyPrgm - (L_BRACK, R_BRACK)
vac = (0, anyPrgm)

pointerOp = (POINTER_PLUS..POINTER_COMMA) - POINTER_R_BRACK
northbound = (NORTH_PLUS..NORTH_COMMA)
northboundNOP = (northbound, NORTH_NOP)
northboundOp = northbound - NORTH_R_BRACK
westbound = (WEST_PLUS..WEST_COMMA)
eastbound = (EAST_PLUS..EAST_COMMA)

westshadows = (WEST_SHADOW_PLUS..WEST_SHADOW_COMMA, WEST_SHADOW)
eastshadows = (EAST_SHADOW_PLUS..EAST_SHADOW_COMMA, EAST_SHADOW)


##### INITIAL TELESCOPING OF BRACKET-ENCLOSED STUFF #####
# move program cell down if it has a closing bracket to its east
(prgm, R_BRACK), E R_BRACK, SE..NW vac, N..NE 0; 0 -> S[0]

# move program cell down if the cell to its east is below it
(prgm, R_BRACK), SE anyPrgm, S..E vac; 0 -> S[0]

## (NOTE: The above two groups aren't even necessary but symmetry finishes sooner) ##

# move program cell down if it has an opening bracket to its west
(prgm, L_BRACK), W L_BRACK, any, 0, NE..SW vac; 0 -> S[0]

# move program cell down if the cell to its west is below it
(prgm, L_BRACK), SW anyPrgm, W..S vac; 0 -> S[0]

# special-casing for ][ cases. could probably be handled above, hm
L_BRACK, E..SE vac, W 0, SW R_BRACK, W..NE 0; 0 -> S:L_BRACK
R_BRACK, SE L_BRACK, 0, vac, vac, NW..E 0; 0 -> S:R_BRACK

# if a bracket has nothing in its mouth, assume it needs to travel south
# to catch up to a different level
# In the same vein, spawn a cell if in an empty cell between a bracket (N) and
# a prgm tape bit (SW/SE)
L_BRACK, N..SW 0, W vac, NW vac; 0 -> S:L_BRACK
R_BRACK, NE..E vac, SE..N 0; 0 -> S:R_BRACK

# if the above happens,  move the now-hanging-one-lvl-too-high prgm tape data south
prgm, E prgm, 0, 0, SW R_BRACK, 0, NW..NE 0; 0 -> S[0]  # ]x
prgm, SE L_BRACK, 0, 0, W prgm, NW..E 0; 0 -> S[0]  # x[


##### SHADOW CELL #####
# If a northbound cell is coming at shadow from a corner, move toward it & load self with it
eastshadows, SW northboundNOP, W..S any; 0 -> W[SW: eastshadows]
westshadows, SW northboundNOP, W..S any; 0 -> W[SW: westshadows]

eastshadows, SE northboundNOP, S..E any; 0 -> E[SE: eastshadows]
westshadows, SE northboundNOP, S..E any; 0 -> E[SE: westshadows]

# If it's coming from right below, just load without moving
eastshadows, S northboundNOP, SW..SE any; [S: eastshadows]
westshadows, S northboundNOP, SW..SE any; [S: westshadows]

# If you're a "loaded" shadow cell, turn into a normal one and release your signal
# (eastshadows, westshadows), N..NW any; [0: (EAST_SHADOW*eastshadows, WEST_SHADOW, ...)] -> N[0: (eastbound, _, westbound, _)]
eastshadows, N..NW any; EAST_SHADOW -> N[0: (eastbound, _)]
westshadows, N..NW any; WEST_SHADOW -> N[0: (westbound, _)]

# override signal movement from next section
(EAST_SHADOW, WEST_SHADOW), N..NW any; [0]


##### POINTER MOVEMENT #####
# don't put out north-bound signals after hitting r_brack
pointerOp, N..NE any, E R_BRACK, SE..NW any; POINTER -> NE:NORTH_R_BRACK
# otherwise do
(POINTER, pointerOp), any, 0, vac, SE (L_BRACK, prgm), S..SW vac, (L_BRACK, vac), any; 0 -> N[0: (_, northboundOp)]  E[SE: (POINTER, pointerOp)]
L_BRACK, N POINTER, NE..E 0, SE (L_BRACK, prgm), S..NW any; L_BRACK -> N:NORTH_NOP  E[SE: (POINTER, pointerOp)]

# make north_r_brack wait one generation before going up so it's in sync
NORTH_R_BRACK, W northboundNOP, NW..SW any; [0] -> N:0
# move signals
(NORTH_R_BRACK, northboundNOP), N..NW any; 0 ~> N[0]
(WEST_R_BRACK, westbound), N..NW any; 0 ~> W[0]
(EAST_R_BRACK, eastbound), N..NW any; 0 ~> E[0]
