@NUTSHELL bf

Brainfuck.

 0: Vacuum

 1: +  {PLUS}
 2: -  {MINUS}
 3: ]  {R_BRACK}
 4: [  {L_BRACK}
 5: <  {L_ANGLE}
 6: >  {R_ANGLE}
 7: .  {DOT}
 8: ,  {COMMA}

 9: Plain pointer  {POINTER}
10: Pointer +  {POINTER_PLUS}
11: Pointer -  {POINTER_MINUS}
12: Pointer [  {POINTER_R_BRACK}
13: Pointer <  {POINTER_L_ANGLE}
14: Pointer >  {POINTER_R_ANGLE}
15: Pointer .  {POINTER_DOT}
16: Pointer ,  {POINTER_COMMA}
17: Westbound backtracking pointer  {WEST_POINTER}

18: Northbound no-op {NORTH_NOP}

19: Northbound +  {NORTH_PLUS}
20: Northbound -  {NORTH_MINUS}
21: Northbound ]  {NORTH_R_BRACK}
22: Northbound <  {NORTH_L_ANGLE}
23: Northbound >  {NORTH_R_ANGLE}
24: Northbound .  {NORTH_DOT}
25: Northbound ,  {NORTH_COMMA}

26: Westbound +  {WEST_PLUS}
27: Westbound -  {WEST_MINUS}
28: Westbound ]  {WEST_R_BRACK}
29: Westbound <  {WEST_L_ANGLE}
30: Westbound >  {WEST_R_ANGLE}
31: Westbound .  {WEST_DOT}
32: Westbound ,  {WEST_COMMA}

33: Eastbound +  {EAST_PLUS}
34: Eastbound -  {EAST_MINUS}
35: Eastbound ]  {EAST_R_BRACK}
36: Eastbound <  {EAST_L_ANGLE}
37: Eastbound >  {EAST_R_ANGLE}
38: Eastbound .  {EAST_DOT}
39: Eastbound ,  {EAST_COMMA}

40: Southbound ,  {SOUTH_COMMA}

41: Eastward-pointing shadow cell  {EAST_SHADOW}
42: Westward-pointing shadow cell  {WEST_SHADOW}

43: Westbound shadow +  {WEST_SHADOW_PLUS}
44: Westbound shadow -  {WEST_SHADOW_MINUS}
45: Westbound shadow ]  {WEST_SHADOW_R_BRACK}
46: Westbound shadow <  {WEST_SHADOW_L_ANGLE}
47: Westbound shadow >  {WEST_SHADOW_R_ANGLE}
48: Westbound shadow .  {WEST_SHADOW_DOT}
49: Westbound shadow ,  {WEST_SHADOW_COMMA}

50: Eastbound shadow +  {EAST_SHADOW_PLUS}
51: Eastbound shadow -  {EAST_SHADOW_MINUS}
52: Eastbound shadow ]  {EAST_SHADOW_R_BRACK}
53: Eastbound shadow <  {EAST_SHADOW_L_ANGLE}
54: Eastbound shadow >  {EAST_SHADOW_R_ANGLE}
55: Eastbound shadow .  {EAST_SHADOW_DOT}
56: Eastbound shadow ,  {EAST_SHADOW_COMMA}

57: Pointer delay state  {DELAYED_POINTER}

58: Data pointer    {DATA_POINTER}
59: Data-pointer +  {DATA_POINTER_PLUS} == "data-output prompter"
60: Data-pointer -  {DATA_POINTER_MINUS}
61: Data-pointer ]  {DATA_POINTER_R_BRACK}
62: Data-pointer <  {DATA_POINTER_L_ANGLE}
63: Data-pointer >  {DATA_POINTER_R_ANGLE}
64: Data-pointer .  {DATA_POINTER_DOT}
65: Data-pointer ,  {DATA_POINTER_COMMA}

66:           {DATA}  Data
67:       {DATA_OUT}  Data turned output signal; reverts to data on next generation
68: {FINAL_DATA_OUT}  Data-born output signal that will not extend westward anymore
69:       {ZERO_OUT}  Vacuum turned output signal; reverts to vacuum on next
70: {FINAL_ZERO_OUT}  Vacuum-born output signal that will not extend westward anymore

71:  {DATA_PLUS}  Plus sign (incrementor) moving through data
72: {DATA_MINUS}  Minus sign (decrementor) moving through data

73: Second pointer delay state  {DELAYED_POINTER_2}  (down here b/c poor planning lol)

74: eastbound YES signal   {EAST_LOOP} (not 0, keep looping) from data pointer after testing for r-bracket 
75: westbound YES signal   {WEST_LOOP}
76: southbound YES signal  {SOUTH_LOOP}
77: eastbound NO signal    {EAST_BREAK} (is 0, continue)
78: westbound NO signal    {WEST_BREAK}
79: southbound NO signal   {SOUTH_BREAK}
80: west shadow holding southbound NO   {WEST_SHADOW_BREAK}
81: west shadow holding southbound YES  {WEST_SHADOW_LOOP}
82: east shadow holding southound NO    {EAST_SHADOW_BREAK}
83: east shadow holding southbound YES  {EAST_SHADOW_LOOP}

84: Input                 {NORTH_INPUT}
85: Input head            {INPUT_HEAD}, which covers the input tape & directs input toward the data pointer
86: Input traveling east  {EAST_INPUT}

87: misc state {BLANK_1}
88: misc state {BLANK_2}
89: eastbound misc state  {BLANK_EAST}

90: blank input  {INPUT_0}
91: {FRESH_INPUT} "Uninitialized" input data; this is only here for ease of storage in RLE format,
    because otherwise the vertical input tape is very unfriendly to Golly. It moves diagonally to
    the southeast until thereâ€™s something above it
92: {FRESH_0}  Uninitialized \x00 input, same as above
93: {FRESH_INPUT_HEAD} Uninitialized input head, same as above

94: Yet another pointer delay state just to absolutely be sure of no timing conflicts  {DELAYED_POINTER_3}
95: Loop-skipping pointer  {POINTER_SKIP} (antithesis to WEST_POINTER)


+ To use:
  Start with this template.
    x = 5, y = 4, rule = bf
    2.qJ$4.pR$rM$4.I!
  - Enter a BF program from left to right, using cellstates 1-8, starting in the dead cell immediately southeast of
    the bottommost live one.
  - Initialize data as diagonal, northwest-leaning unary stacks of state-66 cells, starting each stack in the row
    immediately above the topmost live cell.
  - Initialize input as vertically-stacked vertical stacks of state-84 cells, starting in and going south from the
    cell immediately below the westmost live one and with individual inputs delimited by state-85 cells.
    An input of \x00 can be represented using a single state-90 cell in lieu of the state-84 ones.
  - (Alternatively, should you wish to make your program friendlier to RLE encoding, you may initialize input as
    horizontal (west-pointing) stacks of state-91 cells, delimited by state-93 cells and using state 92 for \x00;
    the input tape will right itself automatically once the simulation starts.)

+ An example:
  x = 61, y = 13, rule = bf
  53.qR$52.qR$51.qR$50.qR$49.qR$47.2qR$42.qR3.2qR$41.qR3.2qR$41.qJ$43.pR
  $7rSrU12rSrU10rSrUrTrU5rSrM$43.I$44.AB2DFHCHCEDGDBCEC!


@COLORS
000: 0
FFF: FINAL_ZERO_OUT  # can't do 000, golly uses it for transparency
FF0: INPUT_HEAD, FRESH_INPUT_HEAD


@ICONS
?  0FF .. FFF
0:  000
1:  FFF
2:  0A0
3:  C00
4:  777
5:  CB0
6:  0AB

#C empty space/shadow
#C NORTH_NOP, EAST_SHADOW..EAST_SHADOW_COMMA, WEST_SHADOW_BREAK..EAST_SHADOW_LOOP, BLANK_1..BLANK_EAST
x = 13, y = 13, rule = bf
3.7A$.3A5D3A$.A9DA$2A2D.3D.2D2A$A2D3.D3.2DA$A3D5.3DA$A4D3.4DA$A3D5.3D
A$A2D3.D3.2DA$2A2D.3D.2D2A$.A9DA$.3A5D3A$3.7A!

#C Left bracket
#C L_BRACK
x = 9, y = 15, rule = bf
2.7D$.8D$3D4A2D$2D5A2D$2D2A5D$2D2A5D$2D2A2D$2D2A2D$2D2A2D$2D2A5D$2D2A
5D$2D5A2D$3D4A2D$.8D$2.7D!

#C Right bracket; R_BRACK, NORTH_R_BRACK, WEST_R_BRACK, EAST_R_BRACK
x = 9, y = 15, rule = bf
7D$8D$2D4A3D$2D5A2D$5D2A2D$5D2A2D$3.2D2A2D$3.2D2A2D$3.2D2A2D$5D2A2D$
5D2A2D$2D5A2D$2D4A3D$8D$7D!

#C Plus sign
#C PLUS, NORTH_PLUS, WEST_PLUS, EAST_PLUS 
x = 15, y = 15, rule = bf
5.5D$4.7D$4.2D3A2D$4.2D3A2D$.5D3A5D$6D3A6D$2D11A2D$2D11A2D$2D11A2D$6D
3A6D$.5D3A5D$4.2D3A2D$4.2D3A2D$4.7D$5.5D!

#C Minus sign
#C MINUS, NORTH_MINUS, WEST_MINUS, EAST_MINUS
x = 15, y = 7, rule = bf
.13D$15D$2D11A2D$2D11A2D$2D11A2D$15D$.13D!

#C Left angle bracket
#C L_ANGLE, NORTH_L_ANGLE, WEST_L_ANGLE, EAST_L_ANGLE
x = 15, y = 13, rule = bf
10.5D$8.7D$6.5D2A2D$4.5D4A2D$2.5D4A4D$5D4A6D$3D4A6D$5D4A6D$2.5D4A4D$
4.5D4A2D$6.5D2A2D$8.7D$10.5D!

#C Right angle bracket
#C R_ANGLE, NORTH_R_ANGLE, WEST_R_ANGLE, EAST_R_ANGLE
x = 15, y = 13, rule = bf
5D$7D$2D2A5D$2D4A5D$4D4A5D$6D4A5D$2.6D4A3D$6D4A5D$4D4A5D$2D4A5D$2D2A
5D$7D$5D!

#C Comma
#C COMMA, NORTH_COMMA, WEST_COMMA, EAST_COMMA, SOUTH_COMMA
x = 13, y = 15, rule = bf
2.9D$.11D$3D7A3D$2D9A2D$2D9A2D$2D9A2D$2D9A2D$2D9A2D$3D8A2D$.6D4A2D$3.
4D4A2D$.5D4A3D$.2D6A4D$.11D$2.9D!

#C Period
#C DOT, NORTH_DOT, WEST_DOT, EAST_DOT
x = 13, y = 13, rule = bf
4.5D$2.9D$.4D3A4D$.2D7A2D$3D7A3D$2D9A2D$2D9A2D$2D9A2D$3D7A3D$.2D7A2D$
.4D3A4D$2.9D$4.5D!

#C "V" shape; instruction pointer
#C POINTER..WEST_POINTER, POINTER_SKIP
x = 11, y = 12, rule = bf
4A3.4A$4A3.4A$5A.5A$.4A.4A$.9A$2.7A$2.7A$3.5A$3.5A$4.3A$4.3A$5.A!

#C Darker "V" shape; delayed pointer
#C DELAYED_POINTER, DELAYED_POINTER_2, DELAYED_POINTER_3
x = 11, y = 12, rule = bf
4D3.4D$4D3.4D$5D.5D$.4D.4D$.9D$2.7D$2.7D$3.5D$3.5D$4.3D$4.3D$5.D!

#C Data pointer
#C DATA_POINTER..DATA_POINTER_COMMA
x = 11, y = 11, rule = bf
4.3E$4.3E$3.5E$3.5E$2.7E$2.7E$.9E$.4E.4E$5E.5E$4E3.4E$4E3.4E!

#C Inert data
#C DATA
x = 13, y = 13, rule = bf
7.4E$6.6E$5.8E$4.9E$3.10E$2.11E$.11E$11E$10E$9E$8E$.6E$2.4E!

#C Active forward-moving data
#C DATA_OUT, FINAL_DATA_OUT, DATA_PLUS
x = 14, y = 14, rule = bf
5.9C$4.10C$4.2C6A2C$4.3C5A2C$4.4C4A2C$3.4C5A2C$2.4C3AC2A2C$.4C3A3CA2C
$4C3A7C$3C3A7C$3C2A4C$8C$.6C$2.4C!

#C Active backward-moving data
#C DATA_MINUS
x = 14, y = 14, rule = bf
8.4F$7.6F$6.8F$5.4F2A3F$.7F3A3F$7F3A4F$2FA3F3A4F$2F2AF3A4F$2F5A4F$2F
4A4F$2F5A3F$2F6A2F$10F$9F!


#C Check mark ('yes', aka 'loop')
#C EAST_LOOP..SOUTH_LOOP
x = 13, y = 13, rule = bf
13B$13B$11BAB$10B2AB$9B3AB$8B3A2B$2BA4B3A3B$2B2A2B3A4B$2B6A5B$3B4A6B$
4B2A7B$13B$13B!

#C X sign ('no', aka 'break')
#C EAST_BREAK..SOUTH_BREAK
x = 13, y = 13, rule = bf
13C$C2A7C2AC$C3A5C3AC$2C3A3C3A2C$3C3AC3A3C$4C5A4C$5C3A5C$4C5A4C$3C3AC
3A3C$2C3A3C3A2C$C3A5C3AC$C2A7C2AC$13C!

#C Digit zero
#C INPUT_0, FRESH_0
x = 9, y = 13, rule = bf
2.5C$.C5AC$C7AC$C2A3C2AC$C2A2C3AC$C2AC4AC$C7AC$C4AC2AC$C3A2C2AC$C2A3C
2AC$C7AC$.C5AC$2.5C!


@TABLE
anyPrgm = (PLUS..COMMA)
prgm = anyPrgm - (L_BRACK, R_BRACK)
vac = (0, anyPrgm)

northbound = (NORTH_PLUS..NORTH_COMMA)
northboundNOP = (northbound, NORTH_NOP)
pointerOps = (POINTER_PLUS..POINTER_COMMA) - POINTER_R_BRACK
northboundOps = northbound - NORTH_R_BRACK
westbound = (WEST_PLUS..WEST_COMMA)
eastbound = (EAST_PLUS..EAST_COMMA)

westshadows = (WEST_SHADOW_PLUS..WEST_SHADOW_COMMA, WEST_SHADOW)
eastshadows = (EAST_SHADOW_PLUS..EAST_SHADOW_COMMA, EAST_SHADOW)

datapointers = (DATA_POINTER_PLUS..DATA_POINTER_COMMA)

vacdata = (0, DATA)
data = (DATA..DATA_MINUS)

# Move uninitialized input data into proper position
(FRESH_INPUT, FRESH_0, FRESH_INPUT_HEAD), E live, SE..NE any; 0 -> SE[0]
(FRESH_INPUT, FRESH_0, FRESH_INPUT_HEAD), N live, NE..NW any; [0: (NORTH_INPUT, INPUT_0, INPUT_HEAD)]

#########################################################
##### INITIAL TELESCOPING OF BRACKET-ENCLOSED STUFF #####
#########################################################

# move program cell down if it has a closing bracket to its east
(prgm, R_BRACK), E R_BRACK, SE..NW vac, N..NE 0; 0 -> S[0]

# move program cell down if the cell to its east is below it
(prgm, R_BRACK), SE anyPrgm, S..E vac; 0 -> S[0]

## (NOTE: The above two groups aren't even necessary but symmetry finishes sooner) ##

# move program cell down if it has an opening bracket to its west
(prgm, L_BRACK), W L_BRACK, any, 0, NE..SW vac; 0 -> S[0]

# move program cell down if the cell to its west is below it
(prgm, L_BRACK), SW anyPrgm, W..S vac; 0 -> S[0]

# special-casing for ][, but could probably be handled above
L_BRACK, E..SE vac, S 0, SW R_BRACK, W..NE 0; 0 -> S:L_BRACK
R_BRACK, SE L_BRACK, 0, vac, vac, NW..E 0; 0 -> S:R_BRACK

# if a bracket has nothing in its mouth, assume it needs to travel south
# to catch up to a different level
# In the same vein, spawn a bracket if there's an empty cell between a bracket (N) and
# a prgm tape bit (SW/SE)
L_BRACK, N..SW 0, W vac, NW vac; 0 -> S:L_BRACK
R_BRACK, NE..E vac, SE..N 0; 0 -> S:R_BRACK

# if the above happens, move the now-hanging-one-lvl-too-high prgm-tape data south
prgm, E prgm, 0, 0, SW R_BRACK, 0, NW..NE 0; 0 -> S[0]  # ]x
prgm, SE L_BRACK, 0, 0, W prgm, NW..E 0; 0 -> S[0]  # x[


################
##### DATA #####
################

### Data-pointer transformations ###
DATA_POINTER, W eastbound, NW..SW any; [W: datapointers]
DATA_POINTER, E westbound, SE..NE any; [E: datapointers]
# If a loaded shadow is directly below data pointer, pretend it's the same as a signal
DATA_POINTER, S (westshadows-WEST_SHADOW, eastshadows-EAST_SHADOW), SW..SE any; [S: datapointers*2]

DATA_POINTER_MINUS, N..NW any; DATA_POINTER -> N:DATA_MINUS
DATA_POINTER_PLUS, N..NW (DATA, any-DATA); DATA_POINTER -> N[(DATA_PLUS, DATA, ...)]
(DATA_POINTER_R_ANGLE, DATA_POINTER_L_ANGLE), N..NW any; 0 -> E[0: (DATA_POINTER, _)]  W[0: (_, DATA_POINTER)]

# Test to see whether there is data above the data pointer -- if yes, send back a LOOP signal ('keep looping'), and if no, send a BREAK ('stop looping')
DATA_POINTER_R_BRACK, N 0, NE..SE any, S (0, WEST_SHADOW, EAST_SHADOW), SW..NW any; DATA_POINTER -> W[S: (_, WEST_SHADOW_BREAK, EAST_SHADOW_BREAK)]
DATA_POINTER_R_BRACK, N live, NE..SE any, S (0, WEST_SHADOW, EAST_SHADOW), SW..NW any; DATA_POINTER -> W[S: (_, WEST_SHADOW_LOOP, EAST_SHADOW_LOOP)]
# we can't send a signal from north to south directly (would exceed lightspeed) so we put it to the west first as a two-step sort of thing; this does delay things by one gen however
(WEST_SHADOW, EAST_SHADOW), NW (WEST_SHADOW_BREAK, EAST_SHADOW_BREAK, WEST_SHADOW_LOOP, EAST_SHADOW_LOOP), N DATA_POINTER, NE..W any; [NW] -> NW:0  W:0
# continue on
WEST_R_BRACK, W DATA_POINTER, NW (0, data), N..SW any; [NW: (EAST_BREAK, EAST_LOOP, ...)]
EAST_R_BRACK, NE (0, data), E DATA_POINTER, SE..N any; [NE: (WEST_BREAK, WEST_LOOP, ...)]

# Reroute west-/eastbound yes/no signals to the south because we need to get them to the program-tape pointer
# ((not relevant at all but i am so proud of how nutshell just takes this and spits out a working translation with no issue))
(WEST_SHADOW, EAST_SHADOW), N (WEST_BREAK, EAST_BREAK, WEST_LOOP, EAST_LOOP), NE..NW any; [N: (WEST_SHADOW_BREAK, EAST_SHADOW_BREAK, WEST_SHADOW_LOOP, EAST_SHADOW_LOOP)] -> N:0  NW[N: (0, _, 0, _)]  NE[N: (_, 0, _, 0)]
(WEST_SHADOW_BREAK, EAST_SHADOW_BREAK, WEST_SHADOW_LOOP, EAST_SHADOW_LOOP), N..NW any; [0: (EAST_SHADOW, WEST_SHADOW, EAST_SHADOW, WEST_SHADOW)] -> S[0: (SOUTH_BREAK, SOUTH_BREAK, SOUTH_LOOP, ...)]

# Finally, the r-brack receives the southbound yes/no signal from above
# If it's BREAK ('yes'), delete the waiting pointer and move it up to where it can continue traveling
# if it's LOOP ('no'), turn the waiting pointer into a westbound one to send it back to the appropriate l-brack
R_BRACK, N (SOUTH_BREAK, SOUTH_LOOP), NE..NW any; [0] -> N[(POINTER_R_BRACK, 0)]  W[N: (0, WEST_POINTER)]

any, SW L_BRACK, W BLANK_1, NW..S any; NORTH_R_BRACK -> W:BLANK_2
WEST_POINTER, W L_BRACK, NW..SE any, S (L_BRACK, prgm), SW any; [S: (BLANK_1, pointerOps)] -> W:L_BRACK
WEST_POINTER, N..NW any; 0 -> W:WEST_POINTER  N:NORTH_NOP

(WEST_BREAK, WEST_LOOP), N..NW any; 0 -> W[0]
(EAST_BREAK, EAST_LOOP), N..NW any; 0 -> E[0]

# Input
# make the comma signal stay put so the data pointer knows where to send the go-poll-for-input request (to have it reach the shadow cell)
WEST_COMMA, E 0, SE..SW any, W DATA_POINTER, NW..NE any; BLANK_1  # just need a random nonmoving state
EAST_COMMA, E DATA_POINTER, SE..SW any, W 0, NW..NE any; BLANK_2  # just need a random nonmoving state
# when input is requested, get the data pointer to zero the current cell,
DATA_POINTER_COMMA, N DATA, NE..NW any; [0] -> N:DATA_MINUS
DATA_POINTER_COMMA, N 0, NE..NW any; DATA_POINTER  # blank cell's cue
# then once done tell the shadow cell to go poll for input
## if nothing to south, send it in appropriate direction
BLANK_1, W DATA_POINTER, NW 0, N..S any, SW 0; 0 -> S:EAST_COMMA
BLANK_2, NE 0, E DATA_POINTER, SE 0, S..N any; 0 -> S:WEST_COMMA
## elif shadow cell to south, stay put and do something stupid to give it the signal regardless
#### (this could be merged into the above transition but I'm lazy)
DATA_POINTER_COMMA, N 0, NE..SE any, S (WEST_SHADOW, EAST_SHADOW), SW..NW any; DATA_POINTER -> SW:EAST_COMMA
# Also have these misc cells not destroy the shadow if it's to their south
(BLANK_1, BLANK_2), S WEST_SHADOW, SW..SE any; 0 -> S:WEST_SHADOW  SW:EAST_COMMA
(BLANK_1, BLANK_2), S EAST_SHADOW, SW..SE any; 0 -> S:EAST_SHADOW  SW:EAST_COMMA
## shadow cell receiving go-poll-for-input signal: (none of those commas would ever appear above it otherwise so we can always assume this'll be the cause)
## on receiving the signal it stays put and sends a comma to the west to ask the input-tape head for its stuff
(EAST_SHADOW, WEST_SHADOW), N..NE any, E WEST_COMMA, SE..SW any, W 0, any; [0] -> S:WEST_COMMA
(EAST_SHADOW, WEST_SHADOW), N..NE any, E 0, SE..SW any, W EAST_COMMA, any; [0] -> S:WEST_COMMA
# Input head doubles as data delimiter so have it move east appropriately to move data with
INPUT_HEAD, N 0, NE NORTH_INPUT, E..NW any; 0 -> N:INPUT_HEAD  # if it's the next up
0, (NORTH_INPUT, INPUT_0), NE..SE any, INPUT_HEAD, SW..NW any; INPUT_HEAD  # if it's farther down
INPUT_HEAD, N INPUT_HEAD, NE..NW any; 0
# Input head is otherwise invincible
INPUT_HEAD, N..NW any; [0]
# When the west comma finds the input head,
# move the comma down one to let the input (if any) know it's there
INPUT_HEAD, NE WEST_COMMA, E..N any; [0] -> N:0  E:WEST_COMMA
INPUT_0, NE WEST_COMMA, E..N any; INPUT_HEAD
# Move input up and then send it back to the shadow cell
NORTH_INPUT, NE (WEST_COMMA, NORTH_INPUT), E..SE any, S..N any; 0 -> E:NORTH_INPUT
NORTH_INPUT, W INPUT_HEAD, NW..SW any; 0 -> N:EAST_INPUT
(NORTH_INPUT, INPUT_0), N..SE 0, S any, SW..NW any; 0 -> N[0]
# When shadow cell receives eastbound input, relay it as an "inc" signal
DATA_POINTER, S (WEST_SHADOW, EAST_SHADOW), SW EAST_INPUT, W..SE any; DATA_POINTER_PLUS
(EAST_SHADOW, WEST_SHADOW), W EAST_INPUT, NW..SW any; [0] -> N[0: (EAST_PLUS, WEST_PLUS)]
# When it receives the "we're done" signal, restore the program-tape pointer & send it on its way
(EAST_SHADOW, WEST_SHADOW), W BLANK_EAST, NW..SW any; [0] -> S:SOUTH_COMMA
0, W BLANK_1, NW SOUTH_COMMA, N..SE any, S L_BRACK, SW COMMA; BLANK_2 -> W:NORTH_R_BRACK  # emulate l-brack test from below
BLANK_1, N SOUTH_COMMA, NE any, E (R_BRACK, prgm, 0), SE..NW vac; POINTER -> NE[E: (NORTH_R_BRACK, _, ...)]
# Also move eastbound input eastward
EAST_INPUT, N..NW any; 0 -> E:EAST_INPUT
# Send a "we're done" signal when there's no data or none left
INPUT_HEAD, E (WEST_COMMA, NORTH_INPUT), SE..NE any; [0] -> SE:BLANK_1
# Move "we're done" signal
BLANK_1, W 0, NW INPUT_HEAD, N..SW any; 0 -> N:BLANK_1
BLANK_1, W INPUT_HEAD, NW 0, N..SW any; 0 -> N:BLANK_EAST
BLANK_EAST, N..NW any; 0 -> E:BLANK_EAST

### Actual handling of data ###
DATA_POINTER_DOT, N..NW any; DATA_POINTER -> N[(0, _, ...)]  # don't output if there's nothing to output
# Output
DATA, S DATA_POINTER_DOT, SW..SE any; DATA_OUT
vacdata, E 0, SE any, S (ZERO_OUT, DATA_OUT), SW..NE any; [0: (FINAL_ZERO_OUT, FINAL_DATA_OUT)]
(FINAL_ZERO_OUT, FINAL_DATA_OUT), N..NW (vacdata, any-vacdata); [0: vacdata] -> N[(FINAL_ZERO_OUT, FINAL_DATA_OUT, _, ...)]

DATA_OUT, N..NW (vacdata, any-vacdata); DATA -> N[(ZERO_OUT, DATA_OUT, _, ...)]
(ZERO_OUT, DATA_OUT), N..NW (vacdata, any-vacdata); [0: vacdata] -> N[(ZERO_OUT, DATA_OUT, _, ...)]  NE[(_, DATA_OUT, _, ...)]

# inc/dec instructions
DATA, SW DATA_MINUS, W..S any; [NE: (0, DATA_MINUS, ...)]
vacdata, SW DATA_PLUS, W..S any; [0: (DATA, DATA_PLUS)]
0, SW DATA_PLUS, W..S any; [NE: (DATA, DATA_PLUS, ...)]

DATA_MINUS, SW 0, W..S any; [NE: (0, DATA, ...)]
DATA_MINUS, NE 0, E..N any; 0
(DATA_PLUS, DATA_MINUS), N..NW any; DATA


#######################
##### SHADOW CELL #####
#######################

# If shadow is touching data pointer, flip direction before moving to it
EAST_SHADOW, NW DATA_POINTER, N..W any; WEST_SHADOW
WEST_SHADOW, NE DATA_POINTER, E..N any; EAST_SHADOW
eastshadows, SE northboundNOP, S..NW any, N DATA_POINTER, NE..E any; 0 -> E[SE: westshadows]
westshadows, SW northboundNOP, W..NW any, N DATA_POINTER, NE..S any; 0 -> W[SW: eastshadows]

# If a northbound cell is coming at shadow from a corner, move toward it & load self with it
eastshadows, SW northboundNOP, W..S any; 0 -> W[SW: eastshadows]
westshadows, SW northboundNOP, W..S any; 0 -> W[SW: westshadows]

eastshadows, SE northboundNOP, S..E any; 0 -> E[SE: eastshadows]
westshadows, SE northboundNOP, S..E any; 0 -> E[SE: westshadows]

# If it's coming from right below, just load without moving
eastshadows, S northboundNOP, SW..SE any; [S: eastshadows]
westshadows, S northboundNOP, SW..SE any; [S: westshadows]

# A "loaded" shadow cell turns into a normal one and releases its signal
eastshadows, N..NW any; EAST_SHADOW -> N[0: (eastbound, _)]
westshadows, N..NW any; WEST_SHADOW -> N[0: (westbound, _)]

# override northbound-signal transitions from ptr-movement section
(EAST_SHADOW, WEST_SHADOW), N..NW any; [0]


############################
##### POINTER MOVEMENT #####
############################

# Stop moving after reaching a comma or l-brack
POINTER_COMMA, E (R_BRACK, vac), SE..NE any; BLANK_1 -> NE:0  # just needs a random non-moving state, so blank_1 works
## l-brack test stuff
(POINTER, pointerOps), SE L_BRACK, S anyPrgm-COMMA, SW..E any; NORTH_R_BRACK -> E:BLANK_2  # send out a test signal
NORTH_R_BRACK, N northbound, NE..NW any; BLANK_1 -> N:0
(BLANK_1, BLANK_2), E BLANK_2, SE..NE any; [0: (BLANK_2, NORTH_R_BRACK)]
### for most cases:
BLANK_2, NW (SOUTH_LOOP, SOUTH_BREAK), N..SE any, S L_BRACK, SW..W any; [NW: (POINTER, POINTER_SKIP)] -> W:0  N:NORTH_NOP
### and for when it's on an l-brack that's right after a first l-brack:
BLANK_2, N (SOUTH_LOOP, SOUTH_BREAK), NE..SE any, S L_BRACK, SW..NW any; [N: (POINTER, POINTER_SKIP)]
### and one more edge case:
BLANK_2, NE (SOUTH_LOOP, SOUTH_BREAK), E..SE any, S L_BRACK, SW..N any; [NE: (POINTER, POINTER_SKIP)] -> E:0
## keep moving eastward till pointer_skip finds an r-brack
POINTER_SKIP, SE (R_BRACK, 0), S..E any; 0 -> E[SE: (POINTER, POINTER_SKIP, ...)]  NE:NORTH_NOP
# Also don't put out north-bound signals after hitting r-brack
pointerOps, N..NE any, E R_BRACK, SE..NW any; POINTER -> NE:NORTH_R_BRACK
# But elsewhere do so as normal
(POINTER, pointerOps), any, 0, vac, SE (L_BRACK, prgm), S..SW vac, (L_BRACK, vac), any; DELAYED_POINTER -> N[0: (_, northboundOps)]
DELAYED_POINTER, N..NW any; DELAYED_POINTER_2
DELAYED_POINTER_2, N..NW any; DELAYED_POINTER_3  # need 3 delay states to give data pointer breathing room from both sides
DELAYED_POINTER_3, any, 0, vac, SE (L_BRACK, prgm), S..SW vac, (L_BRACK, vac), any; 0 -> E[SE: (POINTER, pointerOps)]
L_BRACK, N POINTER, NE..E 0, SE (L_BRACK, prgm), S..NW any; L_BRACK -> N:NORTH_NOP  E[SE: (BLANK_2, pointerOps)]
0, S BLANK_2, SW L_BRACK, W NORTH_NOP, NW..SE 0; NORTH_R_BRACK
0, S NORTH_R_BRACK, SW 0, W NORTH_NOP, NW..SE any; NORTH_R_BRACK -> S:0
# Replicate the above NE-output behavior if a bare pointer is on top of an R_BRACK with another to its east
# (this needs a special case; nothing happens otherwise)
POINTER_R_BRACK, E (R_BRACK, any), SE..NE any; POINTER -> NE[E: (NORTH_R_BRACK, _, ...)]

# Make north_r_brack wait 4 generations before going up to absolutely make sure it won't collide badly with the data pointer
NORTH_R_BRACK, W northbound, NW..SW any; [0] -> N:0
NORTH_R_BRACK, NW northbound, N..W any; BLANK_1 -> N:0  # random non-interfering state (any would do)
BLANK_1, S R_BRACK, SW..SE any; R_BRACK
R_BRACK, S R_BRACK, SW..SE any; NORTH_R_BRACK
# Move signals
(NORTH_R_BRACK, northboundNOP), N..NW any; 0 => N[0]
(WEST_R_BRACK, westbound), N..NW any; 0 => W[0]
(EAST_R_BRACK, eastbound), N..NW any; 0 => E[0]
(SOUTH_COMMA, SOUTH_BREAK, SOUTH_LOOP), N..NW any; 0 -> S[0]

# Pointer stops after reaching end
(POINTER, POINTER_R_BRACK, pointerOps), E..SE 0, S anyPrgm-L_BRACK, SW..NE any; 0 -> E:POINTER
# ...with some edge-case handling
POINTER, E POINTER, SE 0, S R_BRACK, SW..NE any; 0  # avoid double pointer if r-brack is the last character
POINTER, W BLANK_1, NW..S 0, SW any; 0  # avoid punching through the prgm tape if comma is the last character
