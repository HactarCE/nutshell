@RUEL bf

 0: Vacuum
 
 1: +  {PLUS}
 2: -  {MINUS}
 3: [  {R_BRACK}
 4: ]  {L_BRACK}
 5: <  {R_ANGLE}
 6: >  {L_ANGLE}
 7: .  {DOT}
 8: ,  {COMMA}
 
 9: Plain pointer  {POINTER}
10: Pointer +  {POINTER_PLUS}
11: Pointer -  {POINTER_MINUS}
12: Pointer ]  {POINTER_L_BRACK}
13: Pointer <  {POINTER_R_ANGLE}
14: Pointer >  {POINTER_L_ANGLE}
15: Pointer .  {POINTER_DOT}
16: Pointer ,  {POINTER_COMMA}
17: Pointer moving west {WEST_POINTER}

18: Shadow  {SHADOW}

19: Northbound +  {NORTH_PLUS}
20: Northbound -  {NORTH_MINUS}
21: Northbound ]  {NORTH_L_BRACK}
22: Northbound <  {NORTH_R_ANGLE}
23: Northbound >  {NORTH_L_ANGLE}
24: Northbound .  {NORTH_DOT}
25: Northbound ,  {NORTH_COMMA}

26: Westbound +  {WEST_PLUS}
27: Westbound -  {WEST_MINUS}
29: Westbound ]  {WEST_L_BRACK}
30: Westbound <  {WEST_R_ANGLE}
31: Westbound >  {WEST_L_ANGLE}
32: Westbound .  {WEST_DOT}
33: Westbound ,  {WEST_COMMA}

34: Eastbound +  {EAST_PLUS}
35: Eastbound -  {EAST_MINUS}
36: Eastbound ]  {EAST_L_BRACK}
37: Eastbound <  {EAST_R_ANGLE}
38: Eastbound >  {EAST_L_ANGLE}
39: Eastbound .  {EAST_DOT}
40: Eastbound ,  {EAST_COMMA}

41: Southbound +  {SOUTH_PLUS}
42: Southbound -  {SOUTH_MINUS}
43: Southbound ]  {SOUTH_l_BRACK}
44: Southbound <  {SOUTH_R_ANGLE}
45: Southbound >  {SOUTH_L_ANGLE}
46: Southbound .  {SOUTH_DOT}
47: Southbound ,  {SOUTH_COMMA}

48: Eastward-pointing shadow cell  {EAST_SHADOW}
49: Westward-pointing shadow cell  {WEST_SHADOW}


+ Setup:
    Data pointer is placed anywhere, and data is initalized as unary stacks one cell north of it it.
    Program tape is placed so its west end is south and at least two cells east of the data pointer.
    A single state-49 shadow cell is placed directly north of this west end, exactly one row below the data pointer.

+ Post-setup initialization (autonomy starts here):
    Program-tape cells touching a state-3 ] or state-2 [ move down one cell. This change cascades inward until bracket pairs are properly telescoped.
    The instruction pointer starts immediately, being placed initially in the cell directly northwest of the prgm-tape west end -- assuming balanced
    brackets, it will never be able to "beat" the bracket-telescoping (because both happen at lightspeed), so there is no point in delaying its start.

+ Program execution:
    The instruction pointer reads the cell below it.
      [ pass
      ] send TST signal to shadow -> data pointer, which detects whether it has anything above it and returns either 37 (false) or 38 (true)
          false: pass
          true: become state 12 and move west until touching a state-2 [
      + send INC signal to shadow -> data pointer
      - send DEC signal to shadow -> data pointer
      > send RGT signal to shadow -> data pointer
      < send LFT signal to shadow -> data pointer
      , pause and instruct the comma to reel in all stacked unary data below it, which is then fed to shadow -> data pointer as INC
      . send OUT signal to data pointer, which just sends a reader/outputter state-34 up that accumulates to its right
    The instruction pointer will at every step send two signals: one northward to tell the shadow cell to move with it, and one southward
    (passing through the program tape) to tell the input tape to move with it.

+ Input
    The input tape will be stacked vertically in unary, with one state-0 cell separating successive input segments.
    The prgm-tape head will at every execution step send a signal cell downward (by turning the prgm cell below it into a state

@TABEL
states: ?
neighborhood: Moore
symmetries: none

anyPrgm = (PLUS..COMMA)
prgm = anyPrgm-(L_BRACK, R_BRACK)
vac = (0, anyPrgm)

pointerOp = (POINTER_PLUS..POINTER_COMMA)-POINTER_L_BRACK
northbound = (NORTH_PLUS..NORTH_COMMA)-NORTH_L_BRACK

##### INITIAL TELESCOPING OF BRACKET-ENCLOSED STUFF #####

# move program cell down if it has a closing bracket to its east
(prgm, R_BRACK), 0, 0, R_BRACK, SE..NW vac, 0 -> S[0]

# move program cell down if the cell to its east is below it
(prgm, R_BRACK), N..E vac, anyPrgm, S..NW vac, 0 -> S[0]

## (NOTE: The above two groups aren't even necessary but symmetry finishes sooner) ##

# move program cell down if it has an opening bracket to its west
(prgm, L_BRACK), 0, NE..SW vac, L_BRACK, vac, 0 -> S[0]

# move program cell down if the cell to its west is below it
(prgm, L_BRACK), N..S vac, anyPrgm, W..NW vac, 0 -> S[0]

# special-casing for ][ cases. could probably be handled above, hm
L_BRACK, 0, 0, vac, vac, 0, R_BRACK, 0, 0, 0 -> S:L_BRACK
R_BRACK, 0, 0, 0, L_BRACK, 0, vac, vac, 0, 0 -> S:R_BRACK

# if a bracket has nothing in its mouth, assume it needs to travel south
# to catch up to a different level
# In the same vein, spawn a cell if in an empty cell between a bracket (N) and
# a prgm tape bit (SW/SE)
L_BRACK, N..SW 0, vac, vac, 0 -> S:L_BRACK
R_BRACK, 0, vac, vac, SE..NW 0, 0 -> S:R_BRACK

# if the above happens,  move the now-hanging-one-lvl-too-high prgm tape data south
prgm, 0, 0, prgm, 0, 0, R_BRACK, 0, 0, 0 -> S[0]  # ]x
prgm, 0, 0, 0, L_BRACK, 0, 0, prgm, 0, 0 -> S[0]  # x[


##### POINTER MOVEMENT #####
(POINTER, pointerOp), any, 0, vac, prgm, prgm, vac, vac, any, 0 -> N[0: (_, northbound)]  E[SE: pointerOp]

northbound, N..NW any, 0 -> N[0]


@ICONS
? FFFF00 .. FF0000
0: 303030
1: D0D0D0
2: 007FFF
3: 535353
4: AD331D
5: 1A1A1A
6: C0C0C0
7: 6077A0
8: 405780
9: 0000FF

#C 18, empty space
x = 13, y = 13, rule = //10
5.3A$5.3A$2.9A$2.3A3.3A$2.3A3.3A$3A7.3A$3A7.3A$3A7.3A$2.3A3.3A$2.3A3.
3A$2.9A$5.3A$5.3A!

#C Left bracket 4
x = 5, y = 11, rule = //10
5B$5B$2B$2B$2B$2B$2B$2B$2B$5B$5B!

#C Right bracket 3
x = 5, y = 11, rule = //10
5B$5B$3.2B$3.2B$3.2B$3.2B$3.2B$3.2B$3.2B$5B$5B!

#C Plus sign
#C 1 19 26 34 41
x = 11, y = 11, rule = //10
4.3C$4.3C$4.3C$4.3C$11C$11C$11C$4.3C$4.3C$4.3C$4.3C!

#C Minus sign
#C 2 20 27 35 42
x = 11, y = 3, rule = //10
11C$11C$11C!

#C Left angle bracket
#C 6 23 31 38 45
x = 11, y = 11, rule = //10
9.2D$7.4D$5.4D$3.4D$.4D$3D$.4D$3.4D$5.4D$7.4D$9.2D!

#C Right angle bracket
#C 5 22 30 37 44
x = 11, y = 11, rule = //10
2D$4D$2.4D$4.4D$6.4D$8.3D$6.4D$4.4D$2.4D$4D$2D!

#C Comma
#C 8 25 33 40 47
x = 9, y = 11, rule = //10
.7E$9E$9E$9E$9E$9E$.8E$5.4E$5.4E$4.4E$.6E!
 
#C Period
#C 7 24 32 49 46
x = 9, y = 7, rule = //10
.7E$9E$9E$9E$9E$9E$.7E!

#C "V" shape (pointer)
#C 9 10 11 12 13 14 15 16 17
x = 9, y = 9, rule = //10
2G5.2G$2G5.2G$.2G3.2G$.2G3.2G$2.2G.2G$2.2G.2G$3.3G$3.3G$4.G!

#C Data pointer
x = 9, y = 9, rule = //10
4.I$3.3I$3.3I$2.2I.2I$2.2I.2I$.2I3.2I$.2I3.2I$2I5.2I$2I5.2I!