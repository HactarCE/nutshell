table: (line _COMMENT? _NL? | _NL)+

line: NAME ":" _WS? /.+/      -> directive  //LALR unfortunately refuses to parse if this uses a different regex such as /\w+/
  | NAME _WS? "=" _WS? _expr  -> var_decl
  | "!" _expr_no_int          -> print_var
  | transition _ptcds?        -> transition

transition: _expr (_sep tr_state)+ _sep _tr_expr  -> main  //Can't have (INT | reference) here in LALR
tr_state: [cdir _WS] _tr_expr
  | _tr_expr _PERMUTE /[^,;]+/    -> permute_shorthand  //Doesn't make sense to allow cdir *and* permute_shorthand in the same tr_state
cdir: COMPASS_DIR
  | COMPASS_DIR ".." COMPASS_DIR  -> crange

_PERMUTE: _WS? "~" _WS?
_sep: ("," | ";") _WS?  //If this is a terminal rather than a rule it interferes with "," in var-related rules below

_ptcds: normal_ptcds hoist_ptcds? | hoist_ptcds normal_ptcds?
normal_ptcds: _NORMAL_ARROW ptcd (_WS ptcd)*
hoist_ptcds: _HOIST_ARROW ptcd (_WS ptcd)*

_NORMAL_ARROW: _WS? "->" _WS?
_HOIST_ARROW: _WS? "=>" _WS?

ptcd: cdir_delay ":" INT                                                       -> ptcd_bare
  | cdir_delay "[" _ptcd_expr_no_int "]"                                       -> ptcd_map_self
  | cdir_delay "[" (PREVIOUS_BIND | ZERO_BIND) "]"                             -> ptcd_bind_self
  | cdir_delay "[" (PREVIOUS_BIND | ZERO_BIND) ":" _WS? _ptcd_expr_no_int "]"  -> ptcd_map_other

// I'm not sure why I need to specify the "0" explicitly there,
// considering that a 0 is already included in PREVIOUS_BIND.
// (If I don't put it above, Lark will tell me it expected _MULT rather
// than the right square bracket for any "ptcd_bind_self" sequence. idgi)

cdir_delay: COMPASS_DIR ["+" /[0123456789]+/]  //just so that it doesn't get counted as INT terminal


var: _VAR_OPEN (_expr ("," _WS? _expr)* | range) _VAR_CLOSE                                        -> noref_var
tr_var: _VAR_OPEN (_tr_expr ("," _WS? _tr_expr)* | range) _VAR_CLOSE                               -> var
ref_var: _VAR_OPEN (_ref_expr ("," _WS? _ref_expr)* ["," _WS? EXTEND_LAST] | range) _VAR_CLOSE     -> var
ptcd_var: _VAR_OPEN (_ptcd_expr ("," _WS? _ptcd_expr)* ["," _WS? EXTEND_LAST] | range) _VAR_CLOSE  -> var


_expr: _expr_no_int | INT
_expr_no_int: (NAME | range | operation | var)

// These ones are marked "noref" to indicate that they can safely be extracted
// in the 'transformer' phase before transpilation actually starts, b/c _expr
// and _expr_no_int are the only rules guaranteed not to contain any references
operation: INT _MULT INT      -> noref_repeat_int
  | INT _MULT _expr_no_int    -> noref_int_to_var_length
  | _expr_no_int _MULT INT    -> noref_repeat_var
  
  | _expr_no_int _subt _expr  -> noref_subt
  
  | _NEGATE_LIVE _expr        -> noref_live_except
  | _NEGATE_ALL _expr         -> noref_all_except


_tr_expr: _tr_expr_no_int | INT | reference
_tr_expr_no_int: (NAME | range | tr_operation | tr_var)

tr_operation: (INT | reference) _MULT INT      -> repeat_int
  | (INT | reference) _MULT _tr_expr_no_int    -> int_to_var_length
  | _tr_expr_no_int _MULT INT       -> repeat_var
  
  | _tr_expr_no_int _subt _tr_expr  -> subt
  
  | _NEGATE_LIVE _tr_expr           -> live_except
  | _NEGATE_ALL _tr_expr            -> all_except


_ref_expr: _ref_expr_no_int | INT | reference
_ref_expr_no_int: (NAME | range | ref_operation | ref_var)

ref_operation: (INT | reference) _MULT INT      -> repeat_int
  | (INT | reference) _MULT _ref_expr_no_int    -> int_to_var_length
  | _ref_expr_no_int _MULT INT       -> repeat_var
  
  | _ref_expr_no_int _subt _ref_expr  -> subt
  
  | _NEGATE_LIVE _ref_expr           -> live_except
  | _NEGATE_ALL _ref_expr            -> all_except


_ptcd_expr: _ptcd_expr_no_int | INT | reference
_ptcd_expr_no_int: (NAME| LEAVE_ALONE | range | ptcd_operation | ptcd_var)

ptcd_operation: (INT | reference) _MULT INT        -> repeat_int
  | (INT | reference) _MULT _ptcd_expr_no_int      -> int_to_var_length
  | _ptcd_expr_no_int _MULT INT         -> repeat_var
  
  | _ptcd_expr_no_int _subt _ptcd_expr  -> subt
  
  | _NEGATE_LIVE _ptcd_expr             -> live_except
  | _NEGATE_ALL _ptcd_expr              -> all_except


reference: "[" PREVIOUS_BIND "]"                     -> binding
  | "[" PREVIOUS_BIND ":" _WS? _ref_expr_no_int "]"  -> mapping

range: INT _WS? ".." _WS? INT
  | INT _WS? "+" _WS? INT _WS? ".." _WS? INT  -> range_step  //step+lower..upper

_VAR_OPEN: /[({]/
_VAR_CLOSE: /[)}]/

LEAVE_ALONE: "_"
EXTEND_LAST: "..."

_subt: _SUBT | "-" _WS?  //Annoying, but the second variant needs to be specified or it gets confused between subt and negate_all
_MULT: _WS? "*" _WS?
_SUBT: _WS? "-" _WS?

_NEGATE_LIVE: "-"
_NEGATE_ALL: "--"

PREVIOUS_BIND: /0|NE|SE|SW|NW|N|E|S|W/
ZERO_BIND: "0"  //hm
COMPASS_DIR: /NE|SE|SW|NW|N|E|S|W/

// More efficient than /(?!NE|SE|SW|NW|N|E|S|W)[A-Za-z]\w*|(?:NE|SE|SW|NW)[A-Za-z]\w*|(?:N|E|S|W)(?!E|W)[A-Za-z]\w*/
// Thanks to Dr. Memes#1508 (<@138628718968045568>) from Discord TCD
// Modified later to switch from only accepting [A-Za-z]+ sans compass dirs to accepting [A-Za-z]\w* sans the same
NAME: /(?<![A-Za-z])(?!(?:[NS][EW]?|[EW])(?!\w))[A-Za-z]\w*/

INT: /\d+/
_WS: /((?!\n)\s)+/
_NL:  NEWLINE

_COMMENT: /\s*#.*/
_SURROUNDING_WS: /^\s+|\s+$/m
%ignore _COMMENT
%ignore _SURROUNDING_WS
%import common.NEWLINE
