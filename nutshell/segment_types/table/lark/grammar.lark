table: (line | _NL)+

line: NAME ":" _WS? /.+/                  -> directive  //LALR unfortunately refuses to parse if this uses a different regex such as /\w+/
  | NAME _WS? "=" _WS? _expr              -> var_decl
  | "!" _expr_no_int                      -> print_var
  | transition [_arrow ptcd (_WS ptcd)*]  -> transition

transition: _expr (_sep tr_state)+ _sep (_expr | reference)  -> main  //Can't have (INT | reference) here in LALR
tr_state: [cdir _WS] (_expr | reference)
  | [cdir _WS] (_expr | reference) _PERMUTE /[^,;]+/  -> permute_shorthand
cdir: COMPASS_DIR
  | COMPASS_DIR ".." COMPASS_DIR  -> crange

_PERMUTE: _WS? "~" _WS?
_sep: ("," | ";") _WS?  //If this is a terminal rather than a rule it interferes with "," in var-related rules below
_arrow: NORMAL_ARROW | HOIST_ARROW
NORMAL_ARROW: _WS? "->" _WS?
HOIST_ARROW: _WS? "=>" _WS?

var: _VAR_OPEN (_expr ("," _WS? _expr)* | range) _VAR_CLOSE
tr_var: _VAR_OPEN (_tr_expr ("," _WS? _tr_expr)* ["," _WS? EXTEND_LAST] | range) _VAR_CLOSE        -> var
ptcd_var: _VAR_OPEN (_ptcd_expr ("," _WS? _ptcd_expr)* ["," _WS? EXTEND_LAST] | range) _VAR_CLOSE  -> var

_expr: _expr_no_int | INT
_expr_no_int: (NAME | range | operation | var)


operation: INT _MULT INT      -> repeat_int
  | INT _MULT _expr_no_int    -> int_to_var_length
  | _expr_no_int _MULT INT    -> repeat_var
  
  | _expr_no_int _subt _expr  -> subt
  
  | _NEGATE_LIVE _expr        -> live_except
  | _NEGATE_ALL _expr         -> all_except

_tr_expr: _tr_expr_no_int | INT
_tr_expr_no_int: (NAME | range | tr_operation | tr_var | reference)


tr_operation: INT _MULT INT         -> repeat_int
  | INT _MULT _tr_expr_no_int       -> int_to_var_length
  | _tr_expr_no_int _MULT INT       -> repeat_var
  
  | _tr_expr_no_int _subt _tr_expr  -> subt
  
  | _NEGATE_LIVE _tr_expr           -> live_except
  | _NEGATE_ALL _tr_expr            -> all_except

_ptcd_expr: _ptcd_expr_no_int | INT
_ptcd_expr_no_int: (NAME| LEAVE_ALONE | range | ptcd_operation | ptcd_var | reference)


ptcd_operation: INT _MULT INT           -> repeat_int
  | INT _MULT _ptcd_expr_no_int         -> int_to_var_length
  | _ptcd_expr_no_int _MULT INT         -> repeat_var
  
  | _ptcd_expr_no_int _subt _ptcd_expr  -> subt
  
  | _NEGATE_LIVE _ptcd_expr             -> live_except
  | _NEGATE_ALL _ptcd_expr              -> all_except


ptcd: COMPASS_DIR ":" INT                                                       -> ptcd_bare
  | COMPASS_DIR "[" _ptcd_expr_no_int "]"                                       -> ptcd_map_self
  | COMPASS_DIR "[" (PREVIOUS_BIND | ZERO_BIND) "]"                             -> ptcd_bind_self
  | COMPASS_DIR "[" (PREVIOUS_BIND | ZERO_BIND) ":" _WS? _ptcd_expr_no_int "]"  -> ptcd_map_other
// I'm not sure why I need to specify the "0" explicitly there,
// considering that a 0 is already included in PREVIOUS_BIND.
// (If I don't put it above, Lark will tell me it expected _MULT rather than the
// right square bracket for any "ptcd_bind_self" sequence which makes little sense)
// ...so it's a little bit annoying

reference: "[" PREVIOUS_BIND "]"                    -> binding
  | "[" PREVIOUS_BIND ":" _WS? _tr_expr_no_int "]"  -> mapping

range: INT _WS? ".." _WS? INT
  | INT _WS? "~" _WS? INT _WS? ".." _WS? INT -> range_step

_VAR_OPEN: /[({]/
_VAR_CLOSE: /[)}]/

LEAVE_ALONE: "_"
EXTEND_LAST: "..."

_subt: _SUBT | "-" _WS?  //Annoying, but the second variant needs to be specified or it gets confused between subt and negate_all
_MULT: _WS? "*" _WS?
_SUBT: _WS? "-" _WS?

_NEGATE_LIVE: "-"
_NEGATE_ALL: "--"

PREVIOUS_BIND: /0|NE|SE|SW|NW|N|E|S|W/
ZERO_BIND: "0"
COMPASS_DIR: /NE|SE|SW|NW|N|E|S|W/

// More efficient than /(?!NE|SE|SW|NW|N|E|S|W)[A-Za-z]\w*|(?:NE|SE|SW|NW)[A-Za-z]\w*|(?:N|E|S|W)(?!E|W)[A-Za-z]\w*/
// Thanks to Dr. Memes#1508 (<@138628718968045568>) from Discord TCD
// Modified later to switch from only accepting [A-Za-z]+ sans compass dirs to accepting [A-Za-z]\w* sans the same
NAME: /(?<![A-Za-z])(?!(?:[NS][EW]?|[EW])(?!\w))[A-Za-z]\w*/

_WS: /\s+/
_NL:  NEWLINE

_COMMENT: /\s*#.*/
%ignore _COMMENT
%import common (INT, NEWLINE)
